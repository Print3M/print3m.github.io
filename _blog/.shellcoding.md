---
title: Shellcoding (Windows, x64)
---


## Get address PEB structure

[PEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb) (Process Environment Block) is a data structure in Windows that contains information about the current process. Key properties of the PEB include:

- Environment Variables
- Command-Line Arguments
- **Loaded modules** (`ldr` property)
- Other information about the process

**PEB structure is stored in a user-space of the process**. That means, it can be manually read without any WinAPI calls. **For x64 architecture the PEB address is stored in the `gs` register + 0x60 offset**. The `fs` and `gs` segment registers have no specific uses defined by the hardware so they are used by Windows internals.

```asm
mov rbx, gs:[0x60]  ; Get PEB address
```

## Get address of PEB_LDR_DATA

[PEB_LDR_DATA](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data) (PEB Loader Data) contains information about the loaded modules for the process. We need to access this structure to get an address of the `kernel32.dll` and other modules with WinAPI functions.

```c
typedef struct _PEB {
  BYTE              Reserved1[2];  // 2 bytes
  BYTE              BeingDebugged; // 1 byte
  BYTE              Reserved2[1];  // 1 byte
  PVOID             Reserved3[2];  // 16 bytes
  PPEB_LDR_DATA     Ldr;           // <-- We want this
  ...
}
```

We can see that there are 20 bytes from the beginning of the PEB structure to the LDR field. However, this is not true! All because of a compilation phenomenon called **data structure alignment**. On 64-bit Windows the alignment of memory structures is typically 16 bytes. It doesn't matter in this case. But what matters is the fact that 64-bit pointers are aligned to a 8-byte boundary. It means, the address of the pointer in memory cannot be different than multiplication of `0x8`. Let's count bytes before the `PVOID Reserved3` field: 4 bytes! `Reserved4` pointer must be alligned with 4 bytes to round up its address to `0x8` bytes. Read more about [data structure alignment](https://en.wikipedia.org/wiki/Data_structure_alignment).

This is how the final PEB structure looks like (with padding included):

```c
struct _PEB {
  BYTE              Reserved1[2];  // 2 bytes
  BYTE              BeingDebugged; // 1 byte
  BYTE              Reserved2[1];  // 1 byte
  BYTE              Padding[4];    // 4 bytes
  PVOID             Reserved3[2];  // 16 bytes
  PPEB_LDR_DATA     Ldr;           // <-- We want this
  ...
};
```

Now we can clearly see that we need 24 bytes (`0x18`) to get the LDR field. We extract the value of the field by dereferencing (square brackets):

```asm
mov rbx, [rbx+0x18]  ; Get PEB_LDR_DATA address
```

## Get addresses of loaded modules

Now when we have the PEB_LDR_DATA structure we need the address of the `InMemoryOrderModuleList` field:

```c
struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];              // 8 bytes
  PVOID      Reserved2[3];              // 24 bytes
  LIST_ENTRY InMemoryOrderModuleList;
};
```

Get the address of InMemoryOrderModuleList (32 = 0x20 bytes):

```asm
mov rbx, rbx+0x20
```

`LIST_ENTRY` is actually the double-linked list. The first field (the one we've just extracted) is the pointer to the next list entry. By dereferencing addresses, we can get to individual items in the list. Go down the double-link list:

```asm
mov rbx, [rbx]  ; Get address of 1st entry (InMemoryOrderModuleList)
mov rbx, [rbx]  ; Get address of 2st entry (InMemoryOrderModuleList)
mov rbx, [rbx]  ; Get address of 3st entry (InMemoryOrderModuleList)
```

The third entry is the `kernel32.dll`. I'm not sure if this is guaranteed, but this is how people have been doing it for centuries. Who am I to question that...

```c
struct _LDR_DATA_TABLE_ENTRY {
    ..
    LIST_ENTRY  InMemoryOrderLinks; // 16 bytes
    PVOID       Reserved2[2];       // 16 bytes
    PVOID       DllBase;            
    ...
};
```

As we go down the double-linked list (`LIST_ENTRY`) we are already at an offset of the beginning of the structure. Now we have to get the `DllBase` pointer. **DllBase is the address of the DLL in memory**. The distance is 32 bytes (`0x20`):

```asm
mov rbx, [rbx+0x20]   ; Get the kernel32.dll address
```

And here it is! Now, the `rbx` register keeps the address to the beginning of the `kernel32.dll`.

## Get the address of ExportTable (kernel32.dll)

Now we need to get to the `ExportTable` of the `kernel32.dll` module to get information about the WinAPI functions it exports.

PE structure:

1. IMAGE_DOS_HEADER  (we need to get `e_lfanew` address)
2. DOS Stub (X bytes - we need to skip this)
3. PE Headers (starts from `e_lfanew` address)
4. ExportTable (offset of PE headers: 0x70)

Let's take a look at the `IMAGE_DOS_HEADER`. Currently our `rbx` register keeps address of this structure because it's the first structure of any PE file (`kernel32.dll` as well):

```c
typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header
    WORD   e_magic;                // Magic number                      (2)
    WORD   e_cblp;                 // Bytes on last page of file        (2)
    WORD   e_cp;                   // Pages in file                     (2)
    WORD   e_crlc;                 // Relocations                       (2)
    WORD   e_cparhdr;              // Size of header in paragraphs      (2)
    WORD   e_minalloc;             // Minimum extra paragraphs needed   (2)
    WORD   e_maxalloc;             // Maximum extra paragraphs needed   (2)
    WORD   e_ss;                   // Initial (relative) SS value       (2)
    WORD   e_sp;                   // Initial SP value                  (2)
    WORD   e_csum;                 // Checksum                          (2)
    WORD   e_ip;                   // Initial IP value                  (2)
    WORD   e_cs;                   // Initial (relative) CS value       (2)
    WORD   e_lfarlc;               // File address of relocation table  (2)
    WORD   e_ovno;                 // Overlay number                    (2)
    WORD   e_res[4];               // Reserved words                    (8)
    WORD   e_oemid;                // OEM identifier (for e_oeminfo)    (2)
    WORD   e_oeminfo;              // OEM information; e_oemid specific (2)
    WORD   e_res2[10];             // Reserved words                    (20)
    LONG   e_lfanew;               // File address of new exe header    (4)
 } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

We need to get to `e_lfanew` field. This field contains the offset of the PE Headers. Somewhere in PE Headers the ExportTable is kept.

```asm
mov r8, rbx         ; Save kernel32.dll address
mov rbx, [rbx+0x3c] ; Get e_lfanew offset
add rbx, r8         ; kernel32.dll + offset = address of PE Headers 
```

Now `rbx` stores the address of PE Headers. At offset `0x88` of PE Headers the `ExportTable RVA` is placed. `RVA` stands for _Relative Virtual Address_ and it means basically _offset from the beginning of the file_. Using ExportTable RVA and `kernel32.dll` address we are ready to access `ExportTable`.

```asm
xor rcx, rcx
add cx, 0x88           ; RCX = 0x88 (offset of ExportTable RVA)
add rbx, [rbx+rcx]     ; RBX = &PeHeaders + offset of ExportTable RVA = ExportTable RVA
add rbx, r8            ; RBX = ExportTable RVA + &kernel32.dll = &ExportTable
mov r9, rbx            ; R9  = &ExportTable
```

Now the `r9` register stores the address of kernel32.dll `ExportTable`.

## Get the function address

Now we have the address of the structure below. It's so-called Export Address Table (EAT) and it contains all the information about exported functions. Using this structure we want to find an address of WinAPI function `WinExec()`.

```c
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;     // RVA
    DWORD AddressOfNames;         // RVA
    DWORD AddressOfNameOrdinals;  // RVA
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```



## Notes

Dlaczego pisać shellcode w Assembly:

- jest mniejszy
- nie można używać `relative memory calls`

Podstawowe przeznaczenie malware shellcode:

- bind shell
- reverse shell
- download file

Główne zagadnienia shellcodingu:

- uzyskanie adresu głównej struktury procesu: `PEB`
- uzyskanie adresu `kernel32.dll`
- uzyskanie adresów funkcji WinAPI w `kernel32.dll`
- wywłoanie funkcji WinAPI
- używanie stringów w shellcodzie bez sekcji data (wszystko w jednym bloku pamięci)
