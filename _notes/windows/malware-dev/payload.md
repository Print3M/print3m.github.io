---
title: Malware payloads
---

- [1. Placement](#1-placement)
  - [1.1. .data section](#11-data-section)
  - [1.2. .rdata section](#12-rdata-section)
  - [1.3. .text section](#13-text-section)
  - [1.4. .rsrc section](#14-rsrc-section)
- [2. Encryption](#2-encryption)
- [3. Obfuscation](#3-obfuscation)

## 1. Placement
Malware payload can be stored in one of the following PE sections:

- `.data`
- `.rdata`
- `.text`
- `.rsrc`

> **NOTE**: The compiler might decide to store global variables and constants in `.text` section anyway. There is no 100% sure method to determine where the data will be finally stored.

### 1.1. .data section
To store payload in `.data` section initialize global variable. This section is readable and writable.

```c
unsigned char RawPayload[] = { 0xde, 0xad, 0xbe, 0xef }

int main() { /* ... */ }
```

### 1.2. .rdata section
To store payload in `.rdata` section initialize global constant. This section in read-only.

```c
const unsigned char RawPayload[] = { 0xde, 0xad, 0xbe, 0xef }

int main() { /* ... */ }
```

### 1.3. .text section
To store data in `.text` section, one must explicitly instruct the compiler to do this. This section is executable. It's good for small payloads.

```c
#pragma section(".text")
__declspec(allocate(".text")) const unsigned char RawPayload[] = {
    0xde, 0xad, 0xbe, 0xef
}

int main() { /* ... */ }
```

### 1.4. .rsrc section
Visual Studio has an option to embed binary resources (icons, etc.) into PE `.rsrc` section. This section is read-only. The payload cannot be accessed directly at runtime. Instead, several WinAPI functions (especially from `libloaderapi.h`) must be used to access it.

## 2. Encryption
Encryption of the payload can help evade signature-based detection. It is **always necessary** against modern security solutions. Raw payloads are very well detected. It may not be effective against runtime and heuristic analysis.

> **NOTE**: The more encrypted data is embedded in the malicious file, the higher its entropy is. It might be suspicious for security solutions. Entropy should be as normal as possible.

- XOR - the easiest and the stealthiest method. It doesn't require to use any external modules. The same function can be used to encryption and decryption. This encryption is very easy to spot and reversed by an analyst. Some security solutions are able to even brute-force weak encryption keys.
- RC4 - efficient bidirectional encryption algorithm. Its implementation is pretty short and can be easily embedded in the source code of malware. Even NTAPI has some efficient and small implementations of the algorithm (`SystemFunction032` and `SystemFunction033` exported from `advapi32.dll`).
- AES - advanced, secure and pretty complicated encryption algorithm. It operates on blocks of data which are 16-bytes long. It usually requires usage of some external library which can be already signatured by security vendors or produces a lot of WinAPI calls.

## 3. Obfuscation
When it comes to payload obfuscation, the sky is the limit.